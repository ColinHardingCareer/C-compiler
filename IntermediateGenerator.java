/*
*author: colin harding
*
*intermediate generator generates the intermediate code
*
*the generate() method is the method that will activate the generation of intermediate code
*
*subtle differences are:
*
*    (see read me)
*
*    -My = operator prints and reads like the other operators. so a =2 is = a  2
*    - my array operators are changed to calculate the array ptr before sending to the next step
*    - my arithmetic is parsed by a tree and the tree is structured to print the equation left to right
*/

/*

CONSTRUCTORS
IntermediateGenerator():
    default

IntermediateGenerator(SymbolTable sym, ListIterator<int[]> it):
    used to initiate the itermediate code generator with a symbol table and iterator

*/

/*
METHODS

generate():
    this is the method that controlles and handles the generation process
    call this to generate code

ifStatement():
    this is called to interpret if statements it then calls all other parsing methods

whileStatement():
    this is called to interpret while statements this calls all other parsing methods

compEx():
    finds boolean expressions for boolean expressions

compBool():
    finds expressions that result in a boolean value
relop():
    tests if the token is a relation operator

consoleOut():
    this is called to interpret output stream statements this calls other parsing methods

consoleIn():
    this is called to interpret input stream statements this calls other parsing methods

printAssign(ParseTree):
    this prints assignment parse trees generated by assign()

printIfEx(ParseTree):
    this prints if or while statement parse trees generated by ifStatement() or whileStatement()

assign():
    finds an assignment statement

exp():
    finds a mathematical expression

term():
    finds a mathemeatical expression that is higher priority

factor():
    finds a single varibale or negative or parenthesis (the highest of priority)

*/

import java.util.*;

public class IntermediateGenerator {

    ListIterator<int[]> it;
    SymbolTable symbolTable;
    ParseTree parseTree;
    Stack<ParseTree> parentStack;
    Stack<ParseTree> treeStack;
    Stack<String[]> labelStack;
    Stack<String> falseStack;
    Queue<String> code;

    int[] cToken;
    int tempCount = 0;
    int addrCount = 0;
    int labelCount = 0;
    int tempMax = 0;
    int addrMax = 0;

    public IntermediateGenerator() {

    }

    public IntermediateGenerator(SymbolTable sym, ListIterator<int[]> it) {
        this.it = it;
        symbolTable = sym;
        it.previous();
        cToken = it.next();
        parseTree = new ParseTree();
        treeStack = new Stack<ParseTree>();
        parentStack = new Stack<ParseTree>();
        labelStack = new Stack<String[]>();
        falseStack = new Stack<String>();
        code = new LinkedList<>();

    }

    public void generate() {
        boolean found = false;
        if ((cToken[0] == 3 && cToken[1] == 6)) {// check for { 3 6
            found = true;
            cToken = it.next();

            // generate the code
            while (!(cToken[0] == 1 && cToken[1] == 13) && found) {

                if (cToken[0] == 4) {
                    if (assign()) {
                        printAssign(parseTree);
                        cToken = it.next();// should eat so curr is ;
                    } else {
                        found = false;
                    }

                } else if (cToken[0] == 1 && cToken[1] == 4) {
                    if (!consoleOut()) {
                        System.out.println("cout error");
                        found = false;
                    }
                    cToken = it.next();// should eat so curr is ;
                } else if (cToken[0] == 1 && cToken[1] == 5) {
                    if (!consoleIn()) {
                        System.out.println("cin error");
                        found = false;
                    }
                    cToken = it.next();// should eat so curr is ;
                } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                    if (!ifStatement()) {
                        System.out.println("if error");
                        found = false;
                    }
                    // cToken = it.next();// should eat so curr is ;
                } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                    if (!whileStatement()) {
                        System.out.println("while error");
                        found = false;
                    }

                    // cToken = it.next();// should eat so curr is ;
                } else {
                    found = false;
                }
                if (tempMax < tempCount)
                    tempMax = tempCount;
                tempCount = 0;
                if (addrMax < addrCount)
                    addrMax = addrCount;
                addrCount = 0;
            }

            if (cToken[0] == 1 && cToken[1] == 13) {// if there is a return statement
                cToken = it.next();
                if (cToken[0] == 5) {// int check after return
                    cToken = it.next();
                    if (cToken[0] == 3 && cToken[1] == 4) {
                        cToken = it.next();
                    }
                }
            } // end if return

        } // end if {

        if ((cToken[0] == 3 && cToken[1] == 9) && found) {// check for } 3 9
            System.out.println("\nmain parsed");
        } else {
            System.out.println("\nno closing bracket after return");
        }
        System.out.println("=============== " + tempMax);
    }

    // LOGIC STATEMENTS
    public boolean ifStatement() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        String[] labels;
        cToken = it.next();// eats if
        if (cToken[0] == 3 && cToken[1] == 1) {// if (
            cToken = it.next();// e
            if (compEx()) {
                tree = treeStack.pop();
                printIfEx(tree);
                labels = labelStack.pop();
                // print comp ex tree
                if (cToken[0] == 3 && cToken[1] == 2) {// if )
                    cToken = it.next();// eats )

                    /*
                     * =============================================================================
                     * ================================================== inside the if statement
                     * =============================================================================
                     * ==================================================
                     */

                    if (cToken[0] == 3 && cToken[1] == 6) {// if {

                        cToken = it.next();

                        // generate the code
                        while (!(cToken[0] == 3 && cToken[1] == 9)) {// while not }

                            if (cToken[0] == 4) {
                                if (assign()) {
                                    printAssign(parseTree);
                                    cToken = it.next();// should eat so curr is ;
                                } else {

                                    return false;
                                }

                            } else if (cToken[0] == 1 && cToken[1] == 4) {
                                if (!consoleOut()) {
                                    System.out.println("cout error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 5) {
                                if (!consoleIn()) {
                                    System.out.println("cin error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                if (!ifStatement()) {
                                    System.out.println("if error");
                                    return false;
                                }
                                // cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                if (!whileStatement()) {
                                    System.out.println("while error");
                                    return false;
                                }

                                // cToken = it.next();// should eat so curr is ;
                            }

                            // tempCount = 0;
                            found = true;
                        }

                        if ((cToken[0] == 3 && cToken[1] == 9)) {// check for } 3 9
                            cToken = it.next();// eat }

                            found = true;
                        } else {
                            System.out.println("\nif statement error no closing brakets");
                        }

                    } // end If {
                    else {// if there is one stand alone statement

                        if (cToken[0] == 4) {
                            if (assign()) {
                                printAssign(parseTree);
                                cToken = it.next();// should eat so curr is ;
                            } else {
                                return false;
                            }

                        } else if (cToken[0] == 1 && cToken[1] == 4) {
                            if (!consoleOut()) {
                                System.out.println("cout error");
                                return false;
                            }
                            cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 5) {
                            if (!consoleIn()) {
                                System.out.println("cin error");
                                return false;
                            }
                            cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                            if (!ifStatement()) {
                                System.out.println("if error");
                                return false;
                            }
                            // cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                            if (!whileStatement()) {
                                System.out.println("while error");
                                return false;
                            }

                            // cToken = it.next();// should eat so curr is ;
                        }

                        // tempCount = 0;
                        found = true;

                    }
                    if (cToken[0] == 1 && cToken[1] == 9) {
                        System.out.println("goto " + labels[1]);
                        code.add("goto " + labels[1]);
                    }
                    System.out.println(labels[0]);
                    code.add(labels[0]);

                    /*
                     * =============================================================================
                     * ================================================== inside the else statement
                     * =============================================================================
                     * 
                     */
                    boolean cF = true;
                    /*
                     * =============================================================================
                     * ================================================== if it is else if
                     * =============================================================================
                     * 
                     */
                    while (cToken[0] == 1 && cToken[1] == 9 && cF && found) {// else
                        found = false;
                        cToken = it.next();

                        if (cToken[0] == 1 && cToken[1] == 12) {// if if
                            cToken = it.next();

                            if (cToken[0] == 3 && cToken[1] == 1) {// if (
                                cToken = it.next();// e
                                if (compEx()) {
                                    tree = treeStack.pop();
                                    printIfEx(tree);

                                    labels[0] = labelStack.pop()[0];
                                    falseStack.push(labels[0]);
                                    // print comp ex tree
                                    if (cToken[0] == 3 && cToken[1] == 2) {// if )
                                        cToken = it.next();// eats )

                                        if (cToken[0] == 3 && cToken[1] == 6) {// if {

                                            cToken = it.next();

                                            // generate the code
                                            while (!(cToken[0] == 3 && cToken[1] == 9)) {// while not }

                                                if (cToken[0] == 4) {
                                                    if (assign()) {
                                                        printAssign(parseTree);
                                                        cToken = it.next();// should eat so curr is ;
                                                    } else {
                                                        return false;
                                                    }

                                                } else if (cToken[0] == 1 && cToken[1] == 4) {
                                                    if (!consoleOut()) {
                                                        System.out.println("cout error");
                                                        return false;
                                                    }
                                                    cToken = it.next();// should eat so curr is ;
                                                } else if (cToken[0] == 1 && cToken[1] == 5) {
                                                    if (!consoleIn()) {
                                                        System.out.println("cin error");
                                                        return false;
                                                    }
                                                    cToken = it.next();// should eat so curr is ;
                                                } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                                    if (!ifStatement()) {
                                                        System.out.println("if error");
                                                        return false;
                                                    }
                                                    // cToken = it.next();// should eat so curr is ;
                                                } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                                    if (!whileStatement()) {
                                                        System.out.println("while error");
                                                        return false;
                                                    }

                                                    // cToken = it.next();// should eat so curr is ;
                                                }

                                                // tempCount = 0;
                                                found = true;

                                            }

                                            if ((cToken[0] == 3 && cToken[1] == 9)) {// check for } 3 9
                                                cToken = it.next();// eat }
                                                found = true;
                                            } else {
                                                System.out.println("\nif statement error no closing brakets");
                                            }

                                        } // end If {
                                        else {// if there is one stand alone statement

                                            if (cToken[0] == 4) {
                                                if (assign()) {
                                                    printAssign(parseTree);
                                                    cToken = it.next();// should eat so curr is ;
                                                } else {
                                                    return false;
                                                }

                                            } else if (cToken[0] == 1 && cToken[1] == 4) {
                                                if (!consoleOut()) {
                                                    System.out.println("cout error");
                                                    return false;
                                                }
                                                cToken = it.next();// should eat so curr is ;
                                            } else if (cToken[0] == 1 && cToken[1] == 5) {
                                                if (!consoleIn()) {
                                                    System.out.println("cin error");
                                                    return false;
                                                }
                                                cToken = it.next();// should eat so curr is ;
                                            } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                                if (!ifStatement()) {
                                                    System.out.println("if error");
                                                    return false;
                                                }
                                                // cToken = it.next();// should eat so curr is ;
                                            } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                                if (!whileStatement()) {
                                                    System.out.println("while error");
                                                    return false;
                                                }

                                                // cToken = it.next();// should eat so curr is ;
                                            }

                                            // tempCount = 0;
                                            found = true;
                                        }

                                    } // )
                                    else {
                                        return false;
                                    }

                                } else {
                                    return false;
                                }
                            } else {
                                return false;
                            }

                            System.out.println("goto " + labels[1]);
                            code.add("goto " + labels[1]);
                            System.out.println(labels[0]);
                            code.add(labels[0]);
                        } else {
                            cF = false;
                        }

                        /*
                         * =============================================================================
                         * ================================================== end if it is else if
                         * =============================================================================
                         * 
                         */

                        if (cToken[0] == 3 && cToken[1] == 6) {// if {

                            cToken = it.next();

                            // generate the code
                            while (!(cToken[0] == 3 && cToken[1] == 9)) {// while not }

                                if (cToken[0] == 4) {
                                    if (assign()) {
                                        printAssign(parseTree);
                                        cToken = it.next();// should eat so curr is ;
                                    } else {
                                        return false;
                                    }

                                } else if (cToken[0] == 1 && cToken[1] == 4) {
                                    if (!consoleOut()) {
                                        System.out.println("cout error");
                                        return false;
                                    }
                                    cToken = it.next();// should eat so curr is ;
                                } else if (cToken[0] == 1 && cToken[1] == 5) {
                                    if (!consoleIn()) {
                                        System.out.println("cin error");
                                        return false;
                                    }
                                    cToken = it.next();// should eat so curr is ;
                                } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                    if (!ifStatement()) {
                                        System.out.println("if error");
                                        return false;
                                    }
                                    // cToken = it.next();// should eat so curr is ;
                                } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                    if (!whileStatement()) {
                                        System.out.println("while error");
                                        return false;
                                    }

                                    // cToken = it.next();// should eat so curr is ;
                                } else {
                                    return false;
                                }

                                // tempCount = 0;
                                found = true;
                            }

                            if ((cToken[0] == 3 && cToken[1] == 9)) {// check for } 3 9
                                cToken = it.next();// eat }
                                found = true;
                            } else {
                                System.out.println("\nif statement error no closing brakets");
                            }

                        } // end If {
                        else if (cToken[0] != 1) {// if there is one stand alone statement

                            if (cToken[0] == 4) {
                                if (assign()) {
                                    printAssign(parseTree);
                                    cToken = it.next();// should eat so curr is ;
                                } else {
                                    return false;
                                }

                            } else if (cToken[0] == 1 && cToken[1] == 4) {
                                if (!consoleOut()) {
                                    System.out.println("cout error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 5) {
                                if (!consoleIn()) {
                                    System.out.println("cin error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                if (!ifStatement()) {
                                    System.out.println("if error");
                                    return false;
                                }
                                // cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                if (!whileStatement()) {
                                    System.out.println("while error");
                                    return false;
                                }

                                // cToken = it.next();// should eat so curr is ;
                            }

                            // tempCount = 0;
                            found = true;
                        }

                        /*
                         * =============================================================================
                         * ================================================== end if else
                         * =============================================================================
                         * 
                         */

                    }
                    System.out.println(labels[1]);
                    code.add(labels[1]);

                } // )
                else {
                    return false;

                }

            } else {
                return false;

            }
        } else {
            return false;
        }
        return found;
    }

    public boolean whileStatement() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        String[] labels;
        cToken = it.next();// eats while
        String begin = "B_" + labelCount++;
        System.out.println(begin);
        code.add(begin);

        if (cToken[0] == 3 && cToken[1] == 1) {// if (
            cToken = it.next();// (
            if (compEx()) {
                tree = treeStack.pop();
                printIfEx(tree);
                labels = labelStack.pop();
                labels[1] = begin;
                // print comp ex tree
                if (cToken[0] == 3 && cToken[1] == 2) {// if )
                    cToken = it.next();// eats )

                    /*
                     * ============================================== if there are brackets
                     * ==============================================
                     */
                    if (cToken[0] == 3 && cToken[1] == 6) {// if {

                        cToken = it.next();

                        // generate the code
                        while (!(cToken[0] == 3 && cToken[1] == 9)) {// while not }

                            if (cToken[0] == 4) {
                                if (assign()) {
                                    printAssign(parseTree);
                                    cToken = it.next();// should eat so curr is ;
                                } else {
                                    return false;
                                }

                            } else if (cToken[0] == 1 && cToken[1] == 4) {
                                if (!consoleOut()) {
                                    System.out.println("cout error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 5) {
                                if (!consoleIn()) {
                                    System.out.println("cin error");
                                    return false;
                                }
                                cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                                if (!ifStatement()) {
                                    System.out.println("if error");
                                    return false;
                                }
                                // cToken = it.next();// should eat so curr is ;
                            } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                                if (!whileStatement()) {
                                    System.out.println("while error");
                                    return false;
                                }

                                // cToken = it.next();// should eat so curr is ;
                            }

                            // tempCount = 0;
                            found = true;
                        }

                        if ((cToken[0] == 3 && cToken[1] == 9)) {// check for } 3 9
                            cToken = it.next();// eat }

                            found = true;
                        } else {
                            System.out.println("\nif statement error no closing brakets");
                        }

                    } // end If {

                    /*
                     * ============================================== end if there are brackets
                     * ==============================================
                     */

                    /*
                     * ============================================== if there is 1 line
                     * ==============================================
                     */
                    else {// if there is one stand alone statement

                        if (cToken[0] == 4) {
                            if (assign()) {
                                printAssign(parseTree);
                                cToken = it.next();// should eat so curr is ;
                            } else {
                                return false;
                            }

                        } else if (cToken[0] == 1 && cToken[1] == 4) {
                            if (!consoleOut()) {
                                System.out.println("cout error");
                                return false;
                            }
                            cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 5) {
                            if (!consoleIn()) {
                                System.out.println("cin error");
                                return false;
                            }
                            cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 12) {// if if
                            if (!ifStatement()) {
                                System.out.println("if error");
                                return false;
                            }
                            // cToken = it.next();// should eat so curr is ;
                        } else if (cToken[0] == 1 && cToken[1] == 7) {// if while
                            if (!whileStatement()) {
                                System.out.println("while error");
                                return false;
                            }

                            // cToken = it.next();// should eat so curr is ;
                        }

                        // tempCount = 0;
                        found = true;
                    }

                    /*
                     * ============================================== if there is 1 line
                     * ==============================================
                     */
                    System.out.println("goto " + labels[1]);
                    code.add("goto " + labels[1]);
                    System.out.println(labels[0]);
                    code.add(labels[0]);

                } // )
                else {
                    return false;
                }

            } else {
                return false;
            }
        } else {
            return false;
        }

        return found;
    }

    public boolean compEx() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        ParseTree lTree = new ParseTree();
        ParseTree rTree = new ParseTree();
        ParseTree temp = new ParseTree();

        // parentStack.push(tree);
        if (compBool()) {
            found = true;
            lTree = treeStack.pop();
            if (cToken[0] == 2 && (cToken[1] == 5 || cToken[1] == 6) && found) {// if && ||
                found = false;
                tree.left = lTree;
                tree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                cToken = it.next();
                if (compBool()) {
                    found = true;
                    rTree = treeStack.pop();

                    if (cToken[0] == 2 && (cToken[1] == 5 || cToken[1] == 6 || relop())) {
                        found = false;
                        temp.left = rTree;
                        temp.left.parent = temp;
                        temp.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                        cToken = it.next();
                        parentStack.push(temp);
                        if (compEx()) {
                            temp.right = treeStack.pop();
                            temp.right.parent = temp;
                            tree.right = temp;

                            found = true;
                        }

                    } else {
                        tree.right = rTree;
                    }

                    tree.left.parent = tree;
                    tree.right.parent = tree;

                }
            }
        }

        if (found)
            if (tree.lexeme == "") {
                // lTree.parent = parentStack.pop();
                treeStack.push(lTree);
            } else {
                // tree.parent = parentStack.pop();
                treeStack.push(tree);
            }

        return found;

    }

    public boolean compBool() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        parentStack.push(tree);

        if (cToken[0] == 3 && cToken[1] == 1) {// if ( 3 1
            cToken = it.next();// eat relop
            if (compEx()) {
                tree = treeStack.pop();
                if (cToken[0] == 3 && cToken[1] == 2) {// if ) 3 2
                    cToken = it.next();// eat relop
                    found = true;
                }
            }
        }

        else if (exp()) {
            tree.left = treeStack.pop();
            tree.left.parent = tree;
            if (relop()) {
                tree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();// save relop
                cToken = it.next();// eat relop
                parentStack.push(tree);
                if (exp()) {
                    tree.right = treeStack.pop();
                    tree.right.parent = tree;
                    found = true;
                }
            }
        }

        else if (cToken[0] == 2 && cToken[1] == 8) {// if !
            parentStack.pop();
            parentStack.pop();
            tree.lexeme = "^";
            tree.left = new ParseTree();
            tree.left.lexeme = "1";
            tree.left.parent = tree;
            cToken = it.next();// eat relop
            if (compEx()) {
                tree.right = treeStack.pop();
                tree.right.parent = tree;

                found = true;
                // xor with 1
                // print( ^ 1 resultTree temp)
            }
        }

        treeStack.push(tree);
        // tree.parent = parentStack.pop();
        return found;

    }

    public boolean relop() {
        boolean found = false;
        if (cToken[0] == 2 && // if operator
                (cToken[1] == 4 || // ==
                        cToken[1] == 7 || // <=
                        cToken[1] == 13 || // <
                        cToken[1] == 14 || // \!=
                        cToken[1] == 16 || // >
                        cToken[1] == 17)// >=
        ) {

            found = true;
        }

        return found;

    }

    // END LOGIC STATEMENTS

    // IOSTREAM SECTION
    public boolean consoleOut() {
        boolean found = false;

        if (cToken[0] == 1 && cToken[1] == 4) {
            String[] tA = { "", "" };
            tA[0] = "cout";

            cToken = it.next();
            while (cToken[0] == 2 && cToken[1] == 3) {// while insert
                found = false;
                cToken = it.next();
                if (cToken[0] == 7 || cToken[0] == 4 || cToken[0] == 5 || cToken[0] == 6) {

                    tA[1] = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                    cToken = it.next();

                    if (cToken[0] == 3 && cToken[1] == 5) {
                        found = false;
                        ParseTree arrayTree = new ParseTree();
                        ParseTree pointerTree = new ParseTree();
                        pointerTree.left = new ParseTree(tA[1]);
                        pointerTree.left.parent = pointerTree;
                        pointerTree.lexeme = "[]+";
                        cToken = it.next();
                        parentStack.push(pointerTree);
                        if (exp()) {
                            pointerTree.right = treeStack.pop();
                        }

                        if (cToken[0] == 3 && cToken[1] == 8) {// if ]
                            found = true;
                            arrayTree.left = pointerTree;
                            arrayTree.lexeme = "=[]";
                            arrayTree.left.parent = arrayTree;

                            cToken = it.next();

                            printAssign(arrayTree);
                            tA[1] = arrayTree.left.lexeme;

                        }
                    }

                    if (cToken[0] == 2 && (cToken[1] != 2) && cToken[1] != 3) {
                        ParseTree tree = new ParseTree();
                        tree.left = new ParseTree("_t_" + tempCount++);
                        tree.lexeme = "=";
                        tree.right = new ParseTree(symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme());

                        tree.right.parent = tree;
                        tree.right.left = new ParseTree(tA[1]);
                        tree.right.left.parent = tree.right;

                        parentStack.push(tree.right);
                        exp();
                        tree.right.right = treeStack.pop();
                        printAssign(tree);
                        tA[1] = tree.left.lexeme;
                    }

                    // print tA
                    String ts = "";
                    if (tA[0] != "") {
                        for (String s : tA) {
                            ts = ts + s + " ";
                            System.out.print(s + " ");
                        }
                        System.out.println();
                        code.add(ts);
                        ts = "";
                    }
                    // cToken = it.next();
                    found = true;
                }
            }
        }

        return found;
    }

    public boolean consoleIn() {
        boolean found = false;

        if (cToken[0] == 1 && cToken[1] == 5) {
            String[] tA = { "", "" };
            tA[0] = "cin";

            cToken = it.next();
            while (cToken[0] == 2 && cToken[1] == 2) {// while insert
                found = false;
                cToken = it.next();
                if (cToken[0] == 4) {
                    tA[1] = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                    cToken = it.next();

                    if (cToken[0] == 3 && cToken[1] == 5) {
                        found = false;
                        ParseTree arrayTree = new ParseTree();
                        ParseTree pointerTree = new ParseTree();
                        pointerTree.left = new ParseTree(tA[1]);
                        pointerTree.left.parent = pointerTree;
                        pointerTree.lexeme = "[]+";
                        cToken = it.next();
                        parentStack.push(pointerTree);
                        if (exp()) {
                            pointerTree.right = treeStack.pop();
                        }

                        if (cToken[0] == 3 && cToken[1] == 8) {// if ]
                            found = true;
                            arrayTree.left = pointerTree;
                            arrayTree.lexeme = "=[]";
                            arrayTree.left.parent = arrayTree;

                            cToken = it.next();

                            printAssign(arrayTree);
                            tA[1] = arrayTree.left.lexeme;

                        }
                    }

                    if (cToken[0] == 2 && (cToken[1] != 2) && cToken[1] != 3) {
                        ParseTree tree = new ParseTree();
                        tree.left = new ParseTree("_t_" + tempCount++);
                        tree.lexeme = "=";
                        tree.right = new ParseTree(symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme());

                        tree.right.parent = tree;
                        tree.right.left = new ParseTree(tA[1]);
                        tree.right.left.parent = tree.right;

                        parentStack.push(tree.right);
                        exp();
                        tree.right.right = treeStack.pop();
                        printAssign(tree);
                        tA[1] = tree.left.lexeme;
                    }

                    // print tA

                    String ts = "";
                    if (tA[0] != "") {
                        for (String s : tA) {
                            ts = ts + s + " ";
                            System.out.print(s + " ");
                        }
                        System.out.println();
                        code.add(ts);
                        ts = "";
                    }
                    // cToken = it.next();
                    found = true;
                }
            }
        }

        return found;
    }

    // END IOSTREAM SECTION

    // READ PARSE TREE SECTION

    public void printAssign(ParseTree pt) {
        if ("[]=".equals(pt.lexeme)) {
            recTree(pt.left);
            recTree(pt.right);
        } else if ("=[]".equals(pt.lexeme)) {
            recTree(pt.left);
        } else {
            recTree(pt.right);
        }
        if ("=[]".equals(pt.lexeme)) {
            ParseTree tempTree = new ParseTree("_t_" + tempCount++);
            System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + tempTree.lexeme

            );
            code.add(pt.lexeme + " " + pt.left.lexeme + " " + tempTree.lexeme);

        } else {
            System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme);
            code.add(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme);

        }

    }// end print assign

    public void recTree(ParseTree pt) {

        if (pt != null) {

            recTree(pt.left);

            recTree(pt.right);

            if (pt.right != null && pt.left != null) {// if parent of 2 collapse the tree

                if ("[]+".equals(pt.lexeme)) {
                    ParseTree tempTree = new ParseTree("_a_" + addrCount++);

                    System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + tempTree.lexeme

                    );
                    code.add(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + tempTree.lexeme);

                    if (pt.parent.left == pt) {
                        pt.parent.left = tempTree;
                        pt.parent.left.parent = pt.parent;
                    } else {
                        pt.parent.right = tempTree;
                        pt.parent.right.parent = pt.parent;
                    }
                } else {
                    ParseTree tempTree = new ParseTree("_t_" + tempCount++);

                    System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + tempTree.lexeme

                    );
                    code.add(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + tempTree.lexeme);

                    if (pt.parent.left == pt) {
                        pt.parent.left = tempTree;
                        pt.parent.left.parent = pt.parent;
                    } else {
                        pt.parent.right = tempTree;
                        pt.parent.right.parent = pt.parent;
                    }

                }

                return;
            } else if ("=[]".equals(pt.lexeme)) {
                ParseTree tempTree = new ParseTree("_t_" + tempCount++);
                System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + tempTree.lexeme

                );
                code.add(pt.lexeme + " " + pt.left.lexeme + " " + tempTree.lexeme);
                if (pt.parent.left == pt) {
                    pt.parent.left = tempTree;
                } else {
                    pt.parent.right = tempTree;
                }

            }
        }
        return;
    }

    public void printIfEx(ParseTree pt) {

        recTree(pt.left);
        recTree(pt.right);
        String[] labels = { "", "" };
        labels[0] = "F_" + labelCount++;
        labels[1] = "E_" + labelCount++;
        labelStack.push(labels);

        System.out.println(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + labels[0]);
        code.add(pt.lexeme + " " + pt.left.lexeme + " " + pt.right.lexeme + " " + labels[0]);
        return;
    }

    // END READ PARSE TREE SECTION

    // PARSE ASSIGNMENT SECTION
    public boolean assign() {

        boolean found = false;

        if (cToken[0] == 4) {// if curr token is an identifier
            ParseTree assignmentTree = new ParseTree();
            assignmentTree.left = new ParseTree(symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme());
            assignmentTree.left.parent = assignmentTree;
            cToken = it.next();
            if (cToken[0] == 2 && cToken[1] == 15) { // if curr token is =
                assignmentTree.lexeme = "=";
                cToken = it.next();
                parentStack.push(assignmentTree);
                if (exp()) {

                    assignmentTree.right = treeStack.pop();
                    assignmentTree.right.parent = assignmentTree;
                    found = true;
                } // end if exp exists
                parseTree = assignmentTree;
            } // end if =
            else if (cToken[0] == 3 && cToken[1] == 5) {// if array starts with [
                ParseTree arrayTree = new ParseTree();
                ParseTree pointerTree = new ParseTree();
                pointerTree.left = assignmentTree.left;
                pointerTree.left.parent = pointerTree;
                pointerTree.lexeme = "[]+";
                cToken = it.next();
                parentStack.push(pointerTree);

                if (exp()) {
                    pointerTree.right = treeStack.pop();
                }
                if (cToken[0] == 3 && cToken[1] == 8) {
                    cToken = it.next();
                    if (cToken[0] == 2 && cToken[1] == 15) {// assignment after array init
                        ParseTree arrassignmentTree = new ParseTree();
                        cToken = it.next();
                        parentStack.push(null);

                        if (cToken[0] == 6) {
                            arrassignmentTree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1])
                                    .getLexeme();
                            found = true;
                            cToken = it.next();

                        } else if (exp()) {// get the after =
                            arrassignmentTree = treeStack.pop();
                            found = true;
                        }
                        arrayTree.lexeme = "[]=";
                        arrayTree.left = pointerTree;
                        arrayTree.left.parent = arrayTree;
                        arrayTree.right = arrassignmentTree;
                        arrayTree.right.parent = arrayTree;
                        parseTree = arrayTree;
                    }
                }
            }
        } // end if identifier

        return found;
    }// end assign()

    public boolean exp() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        ParseTree tempTree = new ParseTree();
        ParseTree termTree = new ParseTree();
        parentStack.push(tree);
        if (term()) {// if curr token is term

            termTree = treeStack.pop();

            found = true;
            if (cToken[0] == 2 && (cToken[1] == 10 || cToken[1] == 11) && found) {// if curr token is + or -
                found = false;
                tree.left = termTree;

                tree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                cToken = it.next();
                parentStack.push(tree);

                if (!term()) {// if invalid statement
                    found = false;
                } else {
                    found = true;

                    ParseTree termOexp = treeStack.pop();
                    if (cToken[0] == 2 && (cToken[1] == 10 || cToken[1] == 11) && found) {// if factorOterm is a term
                        found = false;
                        tempTree.left = termOexp;
                        tempTree.left.parent = tempTree;
                        tempTree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                        cToken = it.next();
                        parentStack.push(tempTree);
                        if (exp()) {
                            tempTree.right = treeStack.pop();
                            tree.right = tempTree;
                            tree.right.parent = tree;
                            found = true;
                        }
                    } else {// if termOexp is a factor

                        tree.right = termOexp;
                        tree.right.parent = tree;
                        found = true;
                    }

                } // end invalid
            } // end if * or / or %
        } // end if factor
        if (found)
            if (tree.lexeme == "") {
                termTree.parent = parentStack.pop();
                treeStack.push(termTree);
            } else {
                tree.parent = parentStack.pop();
                treeStack.push(tree);
            }
        return found;
    }// end exp()

    public boolean term() {
        boolean found = false;
        ParseTree tree = new ParseTree();
        ParseTree tempTree = new ParseTree();
        ParseTree factorTree = new ParseTree();
        parentStack.push(tree);
        if (factor()) {// if curr token is factor

            factorTree = treeStack.pop();

            found = true;
            if (cToken[0] == 2 && (cToken[1] == 9 || cToken[1] == 12 || cToken[1] == 18) && found) {// if curr token is
                                                                                                    // * or / or %
                found = false;
                tree.left = factorTree;

                tree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                cToken = it.next();
                parentStack.push(tree);

                if (!factor()) {// if invalid statement
                    found = false;
                } else {
                    found = true;

                    ParseTree factorOterm = treeStack.pop();
                    if (cToken[0] == 2 && (cToken[1] == 9 || cToken[1] == 12 || cToken[1] == 18) && found) {// if
                                                                                                            // factorOterm
                                                                                                            // is a term
                        found = false;
                        tempTree.left = factorOterm;
                        tempTree.left.parent = tempTree;
                        tempTree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
                        cToken = it.next();
                        parentStack.push(tempTree);
                        if (term()) {
                            tempTree.right = treeStack.pop();
                            tree.right = tempTree;
                            tree.right.parent = tree;
                            found = true;
                        }
                    } else {// if factorOterm is a factor

                        tree.right = factorOterm;
                        tree.right.parent = tree;
                        found = true;
                    }

                    // parentStack.pop();
                } // end invalid

            } // end if * or / or %
        } // end if factor
        if (found)
            if (tree.lexeme == "") {
                factorTree.parent = parentStack.pop();
                treeStack.push(factorTree);
            } else {
                tree.parent = parentStack.pop();
                treeStack.push(tree);
            }
        return found;
    }// end term()

    public boolean factor() {
        boolean found = false;
        ParseTree tree = new ParseTree();

        if (cToken[0] == 4 || cToken[0] == 5 || (cToken[0] == 2 && cToken[1] == 10)) {// if curr is id or int
            if ((cToken[0] == 2 && cToken[1] == 10)) {
                cToken = it.next();
            }

            tree.lexeme = symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme();
            tree.parent = parentStack.pop();

            found = true;
            cToken = it.next();

            if (cToken[0] == 3 && cToken[1] == 5) {
                found = false;
                ParseTree arrayTree = new ParseTree();
                ParseTree pointerTree = new ParseTree();
                pointerTree.left = tree;
                pointerTree.left.parent = pointerTree;
                pointerTree.lexeme = "[]+";
                cToken = it.next();
                parentStack.push(pointerTree);
                if (exp()) {
                    pointerTree.right = treeStack.pop();
                }

                if (cToken[0] == 3 && cToken[1] == 8) {// if ]
                    found = true;
                    arrayTree.left = pointerTree;
                    arrayTree.lexeme = "=[]";
                    arrayTree.left.parent = arrayTree;
                    treeStack.push(arrayTree);
                    cToken = it.next();
                    return found;

                }
            }

            treeStack.push(tree);

        } else if ((cToken[0] == 3 && cToken[1] == 1)) {// if curr token is (

            cToken = it.next();
            // parentStack.push(tree);
            if (exp()) {// if exp

                if (cToken[0] == 3 && cToken[1] == 2) {// if curr token is )
                    tree = treeStack.pop();
                    found = true;
                    cToken = it.next();
                } // end if curr token is )
            } // end if exp
            treeStack.push(tree);
        } // end if curr token is (
        else if (cToken[0] == 2 && cToken[1] == 11) {

            cToken = it.next();
            if (cToken[0] == 4 || cToken[0] == 5) {
                tree.lexeme = "-";
                tree.left = new ParseTree("0");
                tree.right = new ParseTree(symbolTable.getListMap().get(cToken[0]).get(cToken[1]).getLexeme());
                tree.parent = parentStack.pop();
                found = true;
                cToken = it.next();
            } else if ((cToken[0] == 3 && cToken[1] == 1)) {// if curr token is (
                tree.lexeme = "-";
                tree.left = new ParseTree("0");
                cToken = it.next();
                parentStack.push(tree);

                if (exp()) {// if exp

                    if (cToken[0] == 3 && cToken[1] == 2) {// if curr token is )
                        tree.right = treeStack.pop();
                        tree.right.parent = tree;
                        tree.parent = parentStack.pop();
                        found = true;
                        cToken = it.next();
                    } // end if curr token is )
                } // end if exp

            } // end if curr token is (

            treeStack.push(tree);
        }

        return found;
    }// end exp()

    // END PARSE ASSIGNMENT SECTION

}// end class
